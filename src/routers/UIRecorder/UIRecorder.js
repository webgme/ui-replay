/*globals requireJS*/
/*jshint node:true*/

/**
 * Generated by RestRouterGenerator 2.2.0 from webgme on Thu Dec 15 2016 14:21:04 GMT-0600 (Central Standard Time).
 * To use in webgme add to gmeConfig.rest.components[<routePath>] = filePath.
 *
 * If you put this file in the root of your directory the following config,
 * gmeConfig.rest.component['path/subPath'] = path.join(process.cwd(), './UIRecorder')
 * will expose, e.g. GET <host>/path/subPath/getExample, when running the server.
 */

'use strict';

// http://expressjs.com/en/guide/routing.html
var CONFIG_ID = 'UIRecorderRouter',
    express = require('express'),
    router = express.Router(),
    Q = require('q'),
    mongodb = require('mongodb'),
    webgme = require('webgme'),
    getProjectId = requireJS('common/storage/util').getProjectIdFromOwnerIdAndProjectName,
    defaultConfig = {
        mongo: {
            uri: 'mongodb://127.0.0.1:27017/webgme-ui-recording-data',
            options: {}
        }
    },
    logger,
    config,
    dbConn;

/**
 * Called when the server is created but before it starts to listening to incoming requests.
 * N.B. gmeAuth, safeStorage and workerManager are not ready to use until the start function is called.
 * (However inside an incoming request they are all ensured to have been initialized.)
 *
 * @param {object} middlewareOpts - Passed by the webgme server.
 * @param {GmeConfig} middlewareOpts.gmeConfig - GME config parameters.
 * @param {GmeLogger} middlewareOpts.logger - logger
 * @param {function} middlewareOpts.ensureAuthenticated - Ensures the user is authenticated.
 * @param {function} middlewareOpts.getUserId - If authenticated retrieves the userId from the request.
 * @param {object} middlewareOpts.gmeAuth - Authorization module.
 * @param {object} middlewareOpts.safeStorage - Accesses the storage and emits events (PROJECT_CREATED, COMMIT..).
 * @param {object} middlewareOpts.workerManager - Spawns and keeps track of "worker" sub-processes.
 */
function initialize(middlewareOpts) {
    var ensureAuthenticated = middlewareOpts.ensureAuthenticated,
        getUserId = middlewareOpts.getUserId,
        gmeAuth = middlewareOpts.gmeAuth;

    logger = middlewareOpts.logger.fork('UIRecorder');
    logger.debug('initializing ...');

    function ensureProjectAccess(level, req, res) {
        var userId = getUserId(req),
            projectAuthParams = {
                entityType: gmeAuth.authorizer.ENTITY_TYPES.PROJECT
            },
            projectId = getProjectId(req.params.ownerId, req.params.projectName);

        return gmeAuth.authorizer.getAccessRights(userId, projectId, projectAuthParams)
            .then(function (rights) {
                if (rights && rights[level]) {
                    return {
                        projectId: projectId,
                        userId: userId
                    };
                } else {
                    res.status(403);
                    throw new Error('Read access to webgme project.');
                }
            });
    }

    // Ensure authenticated can be used only after this rule.
    router.use('*', function (req, res, next) {
        // This header ensures that any failures with authentication won't redirect.
        res.setHeader('X-WebGME-Media-Type', 'webgme.v1');
        next();
    });

    // Use ensureAuthenticated if the routes require authentication. (Can be set explicitly for each route.)
    router.use('*', ensureAuthenticated);

    router.get('/:ownerId/:projectName/status/:commitHash', function (req, res, next) {
        ensureProjectAccess('read', req, res)
            .then(function (info) {
                return Q.ninvoke(dbConn, 'collection', info.projectId);
            })
            .then(function (collection) {
                return Q.ninvoke(collection, 'findOne', {_id: '#' + req.params.commitHash});
            })
            .then(function (result) {
                var status = {
                    exists: !!result
                };

                res.json(status);
            })
            .catch(function (err) {
                logger.debug(err);
                next(err);
            });
    });

    router.get('/:ownerId/:projectName/recordings/:startCommit...:endCommit', function (req, res, next) {
        var data = {
                projectId: null,
                number: parseInt(req.query.n, 10) || 100,
                start: '#' + req.params.endCommit
            },
            commits = [];

        ensureProjectAccess('read', req, res)
            .then(function (info) {
                data.projectId = info.projectId;
                data.username = info.userId;

                return middlewareOpts.safeStorage.getHistory(data);
            })
            .then(function (history) {
                var found = false,
                    i;

                for (i = 0; i < history.length; i += 1) {
                    commits.push(history[i]);
                    if (history[i]._id === '#' + req.params.startCommit) {
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    commits = [];
                }

                return Q.ninvoke(dbConn, 'collection', data.projectId);
            })
            .then(function (collection) {
                return Q.all(commits.map(function (commitObject) {
                    return Q.ninvoke(collection, 'findOne', {_id: commitObject._id});
                }));
            })
            .then(function (result) {
                var records = [],
                    len = result.length;

                // This reverses the order suiting for the player.
                while (len--) {
                    if (result[len]) {
                        records.push(result[len]);
                    } else {
                        records.push({
                            _id: commits[len]._id,
                            projectId: data.projectId,
                            commitObject: commits[len],
                            coreObject: {},
                            uiState: {}
                        });
                    }
                }

                res.json(records);
            })
            .catch(function (err) {
                if (err.message.indexOf('object does not exist #') > -1) {
                    res.status(404);
                }
                logger.debug(err);
                next(err);
            });
    });

    router.get('/:ownerId/:projectName/branchStatus/:branchName', function (req, res, next) {
        var data = {
            projectId: null,
            number: parseInt(req.query.n, 10) || 100,
            start: req.params.branchName
        },
            result = {
                totalEntries: null,
                commitIndex: -1,
                commitHash: null
            };

        ensureProjectAccess('read', req, res)
            .then(function (info) {
                data.projectId = info.projectId;
                data.username = info.userId;

                return middlewareOpts.safeStorage.getHistory(data);
            })
            .then(function (history) {
                var i;

                result.totalEntries = history.length;

                for (i = 0; i < history.length; i += 1) {
                    if (history[i].updater.indexOf(data.username) > -1) {
                        result.commitIndex = i;
                        break;
                    }
                }

                if (result.commitIndex > 0 && result.commitIndex < result.totalEntries - 1) {
                    result.commitHash = history[result.commitIndex - 1]._id;
                }

                res.json(result);
            })
            .catch(function (err) {
                logger.debug(err);
                next(err);
            });
    });

    router.put('/:ownerId/:projectName/recording', function (req, res, next) {
        var collection;

        ensureProjectAccess('write', req, res)
            .then(function (info) {
                return Q.ninvoke(dbConn, 'collection', info.projectId);
            })
            .then(function (result) {
                collection = result;
                return Q.ninvoke(collection, 'insert', req.body);
            })
            .then(function () {
                res.sendStatus(201);
            })
            .catch(function (err) {
                logger.debug(err);
                next(err);
            });
    });
}

/**
 * Called before the server starts listening.
 * @param {function} callback
 */
function start(callback) {
    webgme.getComponentsJson(logger)
        .then(function (components) {
            var dbDeferred = Q.defer();
            config = defaultConfig;
            if (components.hasOwnProperty(CONFIG_ID)) {
                config = components[CONFIG_ID];
            }

            mongodb.MongoClient.connect(config.mongo.uri, config.mongo.options, function (err, db) {
                if (err) {
                    dbDeferred.reject(err);
                } else {
                    dbConn = db;
                    dbDeferred.resolve();
                }
            });

            return dbDeferred.promise;
        })
        .nodeify(callback);
}

/**
 * Called after the server stopped listening.
 * @param {function} callback
 */
function stop(callback) {
    if (dbConn) {
        dbConn.close(function () {
            dbConn = null;
            callback();
        });
    } else {
        callback();
    }
}


module.exports = {
    initialize: initialize,
    router: router,
    start: start,
    stop: stop
};
